// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: schedule.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO Schedule (
  invocation_timestamp, 
  request_method, 
  request_url, 
  request_body, 
  request_header,
  request_query, 
  max_retries
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, invocation_timestamp, created_at, request_method, request_body_type, request_body, request_url, request_header, request_query, status, retries_no, max_retries, failure_reason
`

type CreateScheduleParams struct {
	InvocationTimestamp pgtype.Timestamptz
	RequestMethod       Method
	RequestUrl          string
	RequestBody         string
	RequestHeader       []byte
	RequestQuery        []byte
	MaxRetries          pgtype.Int4
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.InvocationTimestamp,
		arg.RequestMethod,
		arg.RequestUrl,
		arg.RequestBody,
		arg.RequestHeader,
		arg.RequestQuery,
		arg.MaxRetries,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.InvocationTimestamp,
		&i.CreatedAt,
		&i.RequestMethod,
		&i.RequestBodyType,
		&i.RequestBody,
		&i.RequestUrl,
		&i.RequestHeader,
		&i.RequestQuery,
		&i.Status,
		&i.RetriesNo,
		&i.MaxRetries,
		&i.FailureReason,
	)
	return i, err
}

const incrementFailure = `-- name: IncrementFailure :one
UPDATE Schedule
SET 
  retries_no = retries_no + 1,
  failure_reason = $2,
  status = "Failed"
WHERE id = $1
RETURNING id, invocation_timestamp, created_at, request_method, request_body_type, request_body, request_url, request_header, request_query, status, retries_no, max_retries, failure_reason
`

type IncrementFailureParams struct {
	ID            int32
	FailureReason string
}

func (q *Queries) IncrementFailure(ctx context.Context, arg IncrementFailureParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, incrementFailure, arg.ID, arg.FailureReason)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.InvocationTimestamp,
		&i.CreatedAt,
		&i.RequestMethod,
		&i.RequestBodyType,
		&i.RequestBody,
		&i.RequestUrl,
		&i.RequestHeader,
		&i.RequestQuery,
		&i.Status,
		&i.RetriesNo,
		&i.MaxRetries,
		&i.FailureReason,
	)
	return i, err
}

const listSchedule = `-- name: ListSchedule :many
SELECT id, invocation_timestamp, created_at, request_method, request_body_type, request_body, request_url, request_header, request_query, status, retries_no, max_retries, failure_reason FROM Schedule
WHERE id = "Scheduled" AND invocation_timestamp > NOW()
ORDER BY invocation_timestamp DESC
LIMIT $1
`

func (q *Queries) ListSchedule(ctx context.Context, limit int32) ([]Schedule, error) {
	rows, err := q.db.Query(ctx, listSchedule, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.InvocationTimestamp,
			&i.CreatedAt,
			&i.RequestMethod,
			&i.RequestBodyType,
			&i.RequestBody,
			&i.RequestUrl,
			&i.RequestHeader,
			&i.RequestQuery,
			&i.Status,
			&i.RetriesNo,
			&i.MaxRetries,
			&i.FailureReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleSuccss = `-- name: ScheduleSuccss :one
UPDATE Schedule
SET 
  status = "Invoked"
WHERE id = $1
RETURNING id, invocation_timestamp, created_at, request_method, request_body_type, request_body, request_url, request_header, request_query, status, retries_no, max_retries, failure_reason
`

func (q *Queries) ScheduleSuccss(ctx context.Context, id int32) (Schedule, error) {
	row := q.db.QueryRow(ctx, scheduleSuccss, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.InvocationTimestamp,
		&i.CreatedAt,
		&i.RequestMethod,
		&i.RequestBodyType,
		&i.RequestBody,
		&i.RequestUrl,
		&i.RequestHeader,
		&i.RequestQuery,
		&i.Status,
		&i.RetriesNo,
		&i.MaxRetries,
		&i.FailureReason,
	)
	return i, err
}
